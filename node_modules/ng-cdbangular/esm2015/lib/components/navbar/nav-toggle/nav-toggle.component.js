import { Component, ElementRef, Input, Renderer2, ViewChild, ViewEncapsulation, } from '@angular/core';
export class NavToggleComponent {
    constructor(elRef, renderer) {
        this.elRef = elRef;
        this.renderer = renderer;
        this.type = 'button';
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.elRef.nativeElement, 'class');
        this.renderer.removeAttribute(this.elRef.nativeElement, 'style');
        if (this.image) {
            this.imagePath = `background-image: url(${this.image})`;
        }
    }
    ngAfterViewInit() {
        if (this.left === true) {
            this.renderer.addClass(this.navToggle.nativeElement, 'navbar-toggler-left');
        }
        if (this.right === true) {
            this.renderer.addClass(this.navToggle.nativeElement, 'navbar-toggler-right');
        }
    }
}
NavToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'CDBNavToggle',
                template: "<ng-container *ngIf=\"image; else elseTemplate\">\n    <button #navToggle [type]=\"type\" class=\"navbar-toggler {{ class }}\" [style]=\"style\">\n        <span class=\"navbar-toggler-icon\" [style]=\"imagePath\"></span>\n    </button>\n</ng-container>\n\n<ng-template #elseTemplate>\n    <button #navToggle [type]=\"type\" class=\"navbar-toggler {{ class }}\" [style]=\"style\">\n        <span class=\"navbar-toggler-icon\"></span>\n    </button>\n</ng-template>",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            },] }
];
NavToggleComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NavToggleComponent.propDecorators = {
    class: [{ type: Input }],
    style: [{ type: Input }],
    image: [{ type: Input }],
    left: [{ type: Input }],
    right: [{ type: Input }],
    type: [{ type: Input }],
    navToggle: [{ type: ViewChild, args: ['navToggle', { static: false },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2LXRvZ2dsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2FwcGxlL0RvY3VtZW50cy9wcm9qZWN0cy9wcm9qZWN0X2RldndhcmVzL0NvbnRyYXN0LUJvb3RzdHJhcC1Bbmd1bGFyL3Byb2plY3RzL25nLWNkYmFuZ3VsYXIvc3JjLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvbmF2YmFyL25hdi10b2dnbGUvbmF2LXRvZ2dsZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsS0FBSyxFQUVMLFNBQVMsRUFDVCxTQUFTLEVBQ1QsaUJBQWlCLEdBQ2xCLE1BQU0sZUFBZSxDQUFDO0FBUXZCLE1BQU0sT0FBTyxrQkFBa0I7SUFVN0IsWUFBb0IsS0FBaUIsRUFBVSxRQUFtQjtRQUE5QyxVQUFLLEdBQUwsS0FBSyxDQUFZO1FBQVUsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUp6RCxTQUFJLEdBQVcsUUFBUSxDQUFDO0lBSW9DLENBQUM7SUFFdEUsUUFBUTtRQUNOLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2pFLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRWpFLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNkLElBQUksQ0FBQyxTQUFTLEdBQUcseUJBQXlCLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQztTQUN6RDtJQUNILENBQUM7SUFFRCxlQUFlO1FBQ2IsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksRUFBRTtZQUN0QixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FDcEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEVBQzVCLHFCQUFxQixDQUN0QixDQUFDO1NBQ0g7UUFFRCxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUNwQixJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsRUFDNUIsc0JBQXNCLENBQ3ZCLENBQUM7U0FDSDtJQUNILENBQUM7OztZQXpDRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGNBQWM7Z0JBQ3hCLDJkQUEwQztnQkFFMUMsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7O2FBQ3RDOzs7WUFiQyxVQUFVO1lBR1YsU0FBUzs7O29CQVlSLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO21CQUNMLEtBQUs7b0JBQ0wsS0FBSzttQkFDTCxLQUFLO3dCQUVMLFNBQVMsU0FBQyxXQUFXLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgT25Jbml0LFxuICBSZW5kZXJlcjIsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdDREJOYXZUb2dnbGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vbmF2LXRvZ2dsZS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL25hdi10b2dnbGUuY29tcG9uZW50LnNjc3MnXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbn0pXG5leHBvcnQgY2xhc3MgTmF2VG9nZ2xlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0IHtcbiAgQElucHV0KCkgY2xhc3M6IHN0cmluZztcbiAgQElucHV0KCkgc3R5bGU6IHN0cmluZztcbiAgQElucHV0KCkgaW1hZ2U6IHN0cmluZztcbiAgQElucHV0KCkgbGVmdDogYm9vbGVhbjtcbiAgQElucHV0KCkgcmlnaHQ6IGJvb2xlYW47XG4gIEBJbnB1dCgpIHR5cGU6IHN0cmluZyA9ICdidXR0b24nO1xuICBpbWFnZVBhdGg6IHN0cmluZztcbiAgQFZpZXdDaGlsZCgnbmF2VG9nZ2xlJywgeyBzdGF0aWM6IGZhbHNlIH0pIG5hdlRvZ2dsZTogRWxlbWVudFJlZjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsUmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5lbFJlZi5uYXRpdmVFbGVtZW50LCAnY2xhc3MnKTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsUmVmLm5hdGl2ZUVsZW1lbnQsICdzdHlsZScpO1xuXG4gICAgaWYgKHRoaXMuaW1hZ2UpIHtcbiAgICAgIHRoaXMuaW1hZ2VQYXRoID0gYGJhY2tncm91bmQtaW1hZ2U6IHVybCgke3RoaXMuaW1hZ2V9KWA7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIGlmICh0aGlzLmxlZnQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoXG4gICAgICAgIHRoaXMubmF2VG9nZ2xlLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICduYXZiYXItdG9nZ2xlci1sZWZ0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yaWdodCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhcbiAgICAgICAgdGhpcy5uYXZUb2dnbGUubmF0aXZlRWxlbWVudCxcbiAgICAgICAgJ25hdmJhci10b2dnbGVyLXJpZ2h0J1xuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==