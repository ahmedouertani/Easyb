import { Component, Input, ViewEncapsulation, ElementRef, Renderer2, } from '@angular/core';
export class CarouselItemComponent {
    constructor(renderer, elRef) {
        this.renderer = renderer;
        this.elRef = elRef;
    }
    getStyles() {
        const slideIndex = this.activeItem - this.itemId;
        if (this.slide) {
            if (slideIndex < 0) {
                return {
                    position: 'absolute',
                    left: '100%',
                };
            }
            else if (slideIndex > 0) {
                return {
                    position: 'absolute',
                    left: '-100%',
                };
            }
            else {
                return {
                    left: '0',
                };
            }
        }
        else {
            return {
                left: '0',
            };
        }
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.elRef.nativeElement, 'class');
        this.renderer.removeAttribute(this.elRef.nativeElement, 'style');
    }
}
CarouselItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'CDBCarousel-item',
                template: "<div #carouselItem data-test=\"carousel-item\" [class.carousel-slide-item]=\"slide\" class=\"carousel-item {{class}}\"\n    [style]='style' [class.active]='true' [ngStyle]=\"getStyles()\">\n    <ng-content></ng-content>\n</div>",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            },] }
];
CarouselItemComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
CarouselItemComponent.propDecorators = {
    class: [{ type: Input }],
    style: [{ type: Input }],
    itemId: [{ type: Input }],
    activeItem: [{ type: Input }],
    slide: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwtaXRlbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2FwcGxlL0RvY3VtZW50cy9wcm9qZWN0cy9wcm9qZWN0X2RldndhcmVzL0NvbnRyYXN0LUJvb3RzdHJhcC1Bbmd1bGFyL3Byb2plY3RzL25nLWNkYmFuZ3VsYXIvc3JjLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvY2Fyb3VzZWwvY2Fyb3VzZWwtaXRlbS9jYXJvdXNlbC1pdGVtLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUVULEtBQUssRUFDTCxpQkFBaUIsRUFDakIsVUFBVSxFQUNWLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQVF2QixNQUFNLE9BQU8scUJBQXFCO0lBaUNoQyxZQUFvQixRQUFtQixFQUFVLEtBQWlCO1FBQTlDLGFBQVEsR0FBUixRQUFRLENBQVc7UUFBVSxVQUFLLEdBQUwsS0FBSyxDQUFZO0lBQUcsQ0FBQztJQXpCdEUsU0FBUztRQUNQLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNqRCxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDZCxJQUFJLFVBQVUsR0FBRyxDQUFDLEVBQUU7Z0JBQ2xCLE9BQU87b0JBQ0wsUUFBUSxFQUFFLFVBQVU7b0JBQ3BCLElBQUksRUFBRSxNQUFNO2lCQUNiLENBQUM7YUFDSDtpQkFBTSxJQUFJLFVBQVUsR0FBRyxDQUFDLEVBQUU7Z0JBQ3pCLE9BQU87b0JBQ0wsUUFBUSxFQUFFLFVBQVU7b0JBQ3BCLElBQUksRUFBRSxPQUFPO2lCQUNkLENBQUM7YUFDSDtpQkFBTTtnQkFDTCxPQUFPO29CQUNMLElBQUksRUFBRSxHQUFHO2lCQUNWLENBQUM7YUFDSDtTQUNGO2FBQU07WUFDTCxPQUFPO2dCQUNMLElBQUksRUFBRSxHQUFHO2FBQ1YsQ0FBQztTQUNIO0lBQ0gsQ0FBQztJQUlELFFBQVE7UUFDTixJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNqRSxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNuRSxDQUFDOzs7WUE1Q0YsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxrQkFBa0I7Z0JBQzVCLCtPQUE2QztnQkFFN0MsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7O2FBQ3RDOzs7WUFSQyxTQUFTO1lBRFQsVUFBVTs7O29CQVdULEtBQUs7b0JBQ0wsS0FBSztxQkFDTCxLQUFLO3lCQUNMLEtBQUs7b0JBRUwsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgT25Jbml0LFxuICBJbnB1dCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIEVsZW1lbnRSZWYsXG4gIFJlbmRlcmVyMixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ0NEQkNhcm91c2VsLWl0ZW0nLFxuICB0ZW1wbGF0ZVVybDogJy4vY2Fyb3VzZWwtaXRlbS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL2Nhcm91c2VsLWl0ZW0uY29tcG9uZW50LnNjc3MnXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbn0pXG5leHBvcnQgY2xhc3MgQ2Fyb3VzZWxJdGVtQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgQElucHV0KCkgY2xhc3M6IHN0cmluZztcbiAgQElucHV0KCkgc3R5bGU6IHN0cmluZztcbiAgQElucHV0KCkgaXRlbUlkOiBhbnk7XG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBhY3RpdmVJdGVtOiBhbnk7XG4gIEBJbnB1dCgpIHNsaWRlOiBhbnk7XG5cbiAgZ2V0U3R5bGVzKCkge1xuICAgIGNvbnN0IHNsaWRlSW5kZXggPSB0aGlzLmFjdGl2ZUl0ZW0gLSB0aGlzLml0ZW1JZDtcbiAgICBpZiAodGhpcy5zbGlkZSkge1xuICAgICAgaWYgKHNsaWRlSW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgbGVmdDogJzEwMCUnLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChzbGlkZUluZGV4ID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIGxlZnQ6ICctMTAwJScsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJzAnLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgZWxSZWY6IEVsZW1lbnRSZWYpIHt9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5lbFJlZi5uYXRpdmVFbGVtZW50LCAnY2xhc3MnKTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsUmVmLm5hdGl2ZUVsZW1lbnQsICdzdHlsZScpO1xuICB9XG59XG4iXX0=