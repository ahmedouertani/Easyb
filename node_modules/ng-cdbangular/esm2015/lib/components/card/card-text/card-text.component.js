import { Component, Input, Renderer2, ElementRef, ViewChild, ViewEncapsulation, } from '@angular/core';
export class CardTextComponent {
    constructor(elRef, renderer) {
        this.elRef = elRef;
        this.renderer = renderer;
        this.style = '';
        this.small = false;
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.elRef.nativeElement, 'class');
        this.renderer.removeAttribute(this.elRef.nativeElement, 'style');
    }
    ngAfterViewInit() {
        if (this.muted === true) {
            this.renderer.addClass(this.cardText.nativeElement, 'text-muted');
        }
    }
}
CardTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'CDBCardText',
                template: "<ng-container [ngSwitch]=\"small === false\">\n\n    <ng-container *ngSwitchCase=\"true\">\n        <p #cardText class=\"card-text {{ class }}\" [style]=\"style\">\n            <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n        </p>\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"false\">\n        <small #cardText class=\"card-text {{ class }}\" [style]=\"style\">\n            <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n        </small>\n    </ng-container>\n\n    <ng-template #content>\n        <ng-content></ng-content>\n    </ng-template>\n\n</ng-container>",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            },] }
];
CardTextComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
CardTextComponent.propDecorators = {
    class: [{ type: Input }],
    style: [{ type: Input }],
    muted: [{ type: Input }],
    small: [{ type: Input }],
    cardText: [{ type: ViewChild, args: ['cardText', { static: false },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FyZC10ZXh0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvYXBwbGUvRG9jdW1lbnRzL3Byb2plY3RzL3Byb2plY3RfZGV2d2FyZXMvQ29udHJhc3QtQm9vdHN0cmFwLUFuZ3VsYXIvcHJvamVjdHMvbmctY2RiYW5ndWxhci9zcmMvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9jYXJkL2NhcmQtdGV4dC9jYXJkLXRleHQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBRVYsU0FBUyxFQUNULGlCQUFpQixHQUNsQixNQUFNLGVBQWUsQ0FBQztBQVF2QixNQUFNLE9BQU8saUJBQWlCO0lBTzVCLFlBQW9CLEtBQWlCLEVBQVUsUUFBbUI7UUFBOUMsVUFBSyxHQUFMLEtBQUssQ0FBWTtRQUFVLGFBQVEsR0FBUixRQUFRLENBQVc7UUFMekQsVUFBSyxHQUFXLEVBQUUsQ0FBQztRQUVuQixVQUFLLEdBQVksS0FBSyxDQUFDO0lBR3FDLENBQUM7SUFFdEUsUUFBUTtRQUNOLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2pFLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRCxlQUFlO1FBQ2IsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLElBQUksRUFBRTtZQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsRUFBRSxZQUFZLENBQUMsQ0FBQztTQUNuRTtJQUNILENBQUM7OztZQXhCRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGFBQWE7Z0JBQ3ZCLDhtQkFBeUM7Z0JBRXpDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJOzthQUN0Qzs7O1lBWEMsVUFBVTtZQURWLFNBQVM7OztvQkFjUixLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO3VCQUNMLFNBQVMsU0FBQyxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgT25Jbml0LFxuICBSZW5kZXJlcjIsXG4gIEVsZW1lbnRSZWYsXG4gIEFmdGVyVmlld0luaXQsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdDREJDYXJkVGV4dCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9jYXJkLXRleHQuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9jYXJkLXRleHQuY29tcG9uZW50LnNjc3MnXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkVGV4dENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCB7XG4gIEBJbnB1dCgpIGNsYXNzOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHN0eWxlOiBzdHJpbmcgPSAnJztcbiAgQElucHV0KCkgbXV0ZWQ6IGJvb2xlYW47XG4gIEBJbnB1dCgpIHNtYWxsOiBib29sZWFuID0gZmFsc2U7XG4gIEBWaWV3Q2hpbGQoJ2NhcmRUZXh0JywgeyBzdGF0aWM6IGZhbHNlIH0pIGNhcmRUZXh0OiBFbGVtZW50UmVmO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsUmVmLm5hdGl2ZUVsZW1lbnQsICdjbGFzcycpO1xuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuZWxSZWYubmF0aXZlRWxlbWVudCwgJ3N0eWxlJyk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgaWYgKHRoaXMubXV0ZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5jYXJkVGV4dC5uYXRpdmVFbGVtZW50LCAndGV4dC1tdXRlZCcpO1xuICAgIH1cbiAgfVxufVxuIl19